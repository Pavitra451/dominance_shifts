initialize() {


	if (exists("slimgui")) {

	defineConstant("s", 0.1); //how beneficial is the mutation
	defineConstant("h", 1.0); //dominance of the beneficial mutation
	defineConstant("file_name", "~/Desktop/lineage_dist_10000_5_1_10.csv"); //name of distribution file
	//generated by "Before_mutational_lineages.slim" code
	defineConstant("results_path", "~/Desktop/");

	}
	
	defineConstant("u", 0);
	initializeMutationRate(u);
	initializeMutationType("m1", 0.5, "f", 0.0); // sweep mutation
	
	m1.convertToSubstitution = F;
	m1.mutationStackPolicy = "f";
	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 0);
	initializeRecombinationRate(0);
	defineConstant("N", 10000);
	

	
	lines = readFile(file_name);
	
	
	defineConstant("random", rdunif(1, 1, rdunif(1, 1, asInteger(10000000)))); 
	
	number_line = lines[random];
	catn(number_line);
	fields = strsplit(number_line, ",");
	defineConstant("hom", asInteger(fields[0])); //homozygotes
	defineConstant("het", asInteger(fields[1])); //homozygotes
	defineConstant("lineages", asInteger(fields[2])); //mutational lineages
	
	defineConstant("info_line", lines[0]+N+","+u+","+s+","+h+","+hom+","+het+","+lineages+",");
	
	first_line = lines[0];
	fields = strsplit(first_line, ",");
	defineConstant("N_previous", asInteger(fields[0]));
	defineConstant("u_previous", asFloat(fields[1]));
	defineConstant("s_previous", asFloat(fields[2]));
	defineConstant("h_previous", asFloat(fields[3]));
	
	
	mut_num_old = -log(u_previous)/log(10);
	s_num_old = -log(s_previous)/log(10);
	dom_num_old = 100*h_previous;
	
	//make -log(s) for values of s less than 1
	s_num_new = -log(s)/log(10);
	dom_num_new = 100*h;
	
	defineConstant("simulation_info", N_previous+"_"+mut_num_old+"_"+s_num_old+"_"+dom_num_old+"_"+s_num_new+"_"+dom_num_new);
	
	
	defineConstant("results_file", results_path+"results_lineages_"+simulation_info+".csv");
	




}


1 {
	sim.addSubpop("p1", N);
	p1.tag = 0;  // indicate that a mutation has not yet been seen

}

1 late (){
	
	if (hom > 0 | het > 0){
		//creates matrix of the number of alleles in homozygotes for each lineage
		//and a matrix containing the number of alleles in heterozygotes for each lineage
		lines = readFile(file_name);
		number_line = lines[random];
		fields = strsplit(number_line, ",");
		

		
		hom_count = matrix(1:lineages, nrow=1);
		het_count = matrix(1:lineages, nrow=1);
		
		for (i in 1:lineages){
			hom_count[0,(i-1)] = 0;
			het_count[0,(i-1)] = 0;
		}
		
		
		counter = 0;
		for (i in 3:((lineages+3) - 1)){
			hom_count[counter]=asInteger(fields[i]);
			counter = counter +1;
		}
		counter = 0;
		for (i in (lineages+3):(3 + (2*lineages) - 1)){
			het_count[counter]=asInteger(fields[i]);
			counter = counter+1;
		}
		counter = 0;
		
		mutation = NULL;
		stored_mutation=NULL;
		tagged_lineage = 99999;
		
		
		total_sample = sample(p1.individuals, hom + het);
		indiv_counter = 0;
		
		
		for (i in 1:lineages){
			i = i -1;
			
			if (hom_count[i] > 0 | het_count[i] >0){
				het_sample = het_count[i];
				
				
				if(hom_count[i] > 0){
					if(hom_count[i] % 2 == 0){hom_sample = hom_count[i]/2;}
					else{hom_sample = ((hom_count[i]-1)/2)+1;}
				}
				else {hom_sample = 0;}
				
				target = total_sample[indiv_counter: (indiv_counter + hom_sample + het_sample - 1)];
				indiv_counter = indiv_counter+ hom_sample + het_sample;
				
				if(hom_sample > 0 & het_sample > 0){
					
					for (j in 0: (het_sample-1)){
						if (j == 0){
							if(i != tagged_lineage){
								target[j].genome1.addNewDrawnMutation(m1,0);
								mutation = target[j].genome1.mutationsOfType(m1);
							}
							else{
								mutation=stored_mutation;
								stored_mutation=NULL;
								tagged_lineage=99999;
								target[j].genome1.addMutations(mutation);
							}
						
						}
						
						else {
							target[j].genome1.addMutations(mutation);
						}
					
					
					}
					
					if (hom_count[i] % 2 == 0) {
						for (q in (het_sample):(het_sample+hom_sample-1)){
							target[q].genome1.addMutations(mutation);
							target[q].genome2.addMutations(mutation);
						}
						mutation = NULL;
					}
					
					
					else if (hom_count[i] % 2 != 0) {
						
						if (hom_count[i] > 1){
							for (q in (het_sample):(het_sample+hom_sample - 1 - 1)){
								target[q].genome1.addMutations(mutation);
								target[q].genome2.addMutations(mutation);
							}
						}
						
						id_number = het_sample+hom_sample - 1;
						target[id_number].genome1.addMutations(mutation);
						target[id_number].genome2.addNewDrawnMutation(m1,0);
						stored_mutation = target[id_number].genome2.mutationsOfType(m1);
						mutation=NULL;
						
						test = i;
						begin = test +1;
						end = lineages -1;
						for (r in begin:end){
							if (hom_count[r]>0){
								hom_count[r] = hom_count[r]-1;
								tagged_lineage = r;
								break;
							
							}
						}
					
					
					}
				
				
				}
				
				else if (het_sample > 0){
					for (q in 0:(het_sample-1)){
						if (q == 0){
							if(i != tagged_lineage){
								target[q].genome1.addNewDrawnMutation(m1,0);
								mutation = target[q].genome1.mutationsOfType(m1);
							}
							else{
								mutation=stored_mutation;
								stored_mutation=NULL;
								tagged_lineage = 99999;
								target[q].genome1.addMutations(mutation);
							}
						
						}
						else{
							target[q].genome1.addMutations(mutation);
						}
					}
					mutation = 0;
				}
				
				else if (hom_sample > 0){
					
					if (hom_count[i] % 2 == 0) {
						for (q in 0:(hom_sample-1)){
							if (q == 0){
								if(i != tagged_lineage){
									target[q].genome1.addNewDrawnMutation(m1,0);
									mutation = target[q].genome1.mutationsOfType(m1);
									target[q].genome2.addMutations(mutation);
								
								}
								else{
									mutation=stored_mutation;
									stored_mutation= NULL;
									tagged_lineage =99999;
									target[q].genome1.addMutations(mutation);
									target[q].genome2.addMutations(mutation);
								}
							}
							
							else{
								target[q].genome1.addMutations(mutation);
								target[q].genome2.addMutations(mutation);
							}
							
						}
					}
					
					else if (hom_count[i] % 2 != 0) {
						
						if (hom_count[i] > 1){
							for (q in 0:(hom_sample - 1 - 1)){
								if (q == 0){
									if(i != tagged_lineage){
										target[q].genome1.addNewDrawnMutation(m1,0);
										mutation = target[q].genome1.mutationsOfType(m1);
										target[q].genome2.addMutations(mutation);
									
									}
									else{
										mutation=stored_mutation;
										stored_mutation= NULL;
										tagged_lineage =99999;
										target[q].genome1.addMutations(mutation);
										target[q].genome2.addMutations(mutation);
									}
								}
								else{
									target[q].genome1.addMutations(mutation);
									target[q].genome2.addMutations(mutation);
								}
							}
							
							id_number = hom_sample - 1;
							target[id_number].genome1.addMutations(mutation);
							target[id_number].genome2.addNewDrawnMutation(m1,0);
							stored_mutation = target[id_number].genome2.mutationsOfType(m1);
							mutation=0;
						
							test = i;
							begin = test +1;
							end = lineages -1;
							for (r in begin:end){
								if (hom_count[r]>0){
									hom_count[r] = hom_count[r]-1;
									tagged_lineage = r;
									break;
							
								}
							}
						
						}
						
					else{
					
							id_number = hom_sample - 1;

							stored_mutation = target[id_number].genome2.mutationsOfType(m1);
							mutation=NULL;
							
							if(i != tagged_lineage){
								target[id_number].genome1.addNewDrawnMutation(m1,0);
								target[id_number].genome2.addNewDrawnMutation(m1,0);
									
							}
							else{
										mutation=stored_mutation;
										stored_mutation= NULL;
										tagged_lineage =99999;
										target[id_number].genome1.addMutations(mutation);
										target[id_number].genome2.addNewDrawnMutation(m1,0);
									
							}

							stored_mutation = target[id_number].genome2.mutationsOfType(m1);
							mutation=NULL;
						
							test = i;
							begin = test +1;
							end = lineages -1;
							for (r in begin:end){
								if (hom_count[r]>0){
									hom_count[r] = hom_count[r]-1;
									tagged_lineage = r;
									break;
							
								}
							}
						
						}
					
					}
				
				
				}
			
			}
		
		
		
		}
		
		
		hom2=0;
		het2=0;
		for (i in 0:(N-1)){
			genome1 = p1.individuals[i].genome1;
			genome2 = p1.individuals[i].genome2;
			
			//counts the number of heterozygotes and homozygotes in the population every generation
			if (genome1.countOfMutationsOfType(m1) & genome2.countOfMutationsOfType(m1)){
				hom2 = hom2+1;
			}
			else if (genome1.countOfMutationsOfType(m1) | genome2.countOfMutationsOfType(m1)){
				het2 = het2+1;
			}
		
		}
		
		if (hom2 != hom | het2 != het){
			output = info_line+"99999999";
			writeFile(results_file, output, append=T);
			sim.simulationFinished();
		}
	
	}
	
	else {
		output = info_line+"0,0,,,,,"+",,,,,,,,,"+",,,,,,,,,";
		writeFile(results_file, output, append=T);
		//catn("No standing variation");
		sim.simulationFinished();
	
	}



}
1:100000 late() {
 	
	
	
	if (p1.tag != sim.countOfMutationsOfType(m1)){
		
		p1.tag = sim.countOfMutationsOfType(m1);
		
		if (p1.tag == 0) {
			
			output = info_line+"3,0,,,,,"+",,,,,,,,,"+",,,,,,,,,";
			writeFile(results_file, output, append=T);
			sim.simulationFinished();
		}
	}
	
	if (all(p1.genomes.countOfMutationsOfType(m1) > 0)) {
		
		freqs = sim.mutationFrequencies(p1, sim.mutationsOfType(m1));
		num_allele = length(freqs);
		
		if (num_allele != p1.tag){
			output = info_line+"99999999";
			writeFile(results_file, output, append=T);
			//catn("error");
		}
		
		if (num_allele == 1){
			
			//code=1, num allele =1, shannon=0, "+evenness=0,", freq_max = 1, sim_generation
			//gini_simpson for all samples =0, num_allle for all samples = 1;
			output = info_line+"1,1,0,0,1,"+sim.generation+","+"0,0,0,0,0,0,0,0,0,"+"1,1,1,1,1,1,1,1,1,";
			writeFile(results_file, output, append=T);
		
		}
		
		else {
			//cat("Soft sweep ended in generation " + sim.generation + "\n");
			//cat("Frequencies:\n");
			//print(sim.mutationFrequencies(p1, sim.mutationsOfType(m1)));
			
			output = info_line+"2,"+num_allele+",";
			
			
			//calculation of shannon index
			
			shannon = 0;
			freq_max = 0;
			simpson_2 = 0;
			simpson_5 = 0;
			simpson_10 = 0;
			simpson_20 = 0;
			simpson_50 = 0;
			simpson_100 = 0;
			simpson_200 = 0;
			simpson_500 = 0;
			simpson_1000 = 0;
			
			
			exp_all_2 = 0;
			exp_all_5 = 0;
			exp_all_10 = 0;
			exp_all_20 = 0;
			exp_all_50 = 0;
			exp_all_100 = 0;
			exp_all_200 = 0;
			exp_all_500 = 0;
			exp_all_1000 = 0;
			
			
			for (i in 1:num_allele){
				
				i=i-1;
				
				freq = freqs[i];
				
				if (freq>freq_max){
					freq_max=freq;
				}
				
				log_freq = log(freq);
				product = freq*log_freq;
				shannon = shannon+product;
				
				simpson_2 = simpson_2 + (freq^2);
				simpson_5 = simpson_5 + (freq^5);
				simpson_10 = simpson_10 + (freq^10);
				simpson_20 = simpson_20 + (freq^20);
				simpson_50 = simpson_50 + (freq^50);
				simpson_100 = simpson_100 + (freq^100);
				simpson_200 = simpson_200 + (freq^200);
				simpson_500 = simpson_500 + (freq^500);
				simpson_1000 = simpson_1000 + (freq^1000);
				
				
				exp_all_2 = exp_all_2 + (1-freq)^2;
				exp_all_5 = exp_all_5 + (1-freq)^5;
				exp_all_10 = exp_all_10 + (1-freq)^10;
				exp_all_20 = exp_all_20 + (1-freq)^20;
				exp_all_50 = exp_all_50 + (1-freq)^50;
				exp_all_100 = exp_all_100 + (1-freq)^100;
				exp_all_200 = exp_all_200 + (1-freq)^200;
				exp_all_500 = exp_all_500 + (1-freq)^500;
				exp_all_1000 = exp_all_1000 + (1-freq)^1000;
			
			
			
			}
			
			shannon = shannon*(-1);
			shannon_max = log(num_allele);
			evenness = shannon/shannon_max;
			
			gini_simpson_2 = 1-simpson_2;
			gini_simpson_5 = 1-simpson_5;
			gini_simpson_10 = 1-simpson_10;
			gini_simpson_20 = 1-simpson_20;
			gini_simpson_50 = 1-simpson_50;
			gini_simpson_100 = 1-simpson_100;
			gini_simpson_200 = 1-simpson_200;
			gini_simpson_500 = 1-simpson_500;
			gini_simpson_1000 = 1-simpson_1000;
			
			
			exp_all_2 = num_allele - exp_all_2;
			exp_all_5 = num_allele - exp_all_5;
			exp_all_10 = num_allele - exp_all_10;
			exp_all_20 = num_allele - exp_all_20;
			exp_all_50 = num_allele - exp_all_50;
			exp_all_100 = num_allele - exp_all_100;
			exp_all_200 = num_allele - exp_all_200;
			exp_all_500 = num_allele - exp_all_500;
			exp_all_1000 = num_allele - exp_all_1000;
			
			output = output+shannon+","+evenness+","+freq_max+","+sim.generation+","+
				gini_simpson_2+","+gini_simpson_5+","+gini_simpson_10+","+gini_simpson_20+","+
				gini_simpson_50+","+gini_simpson_100+","+gini_simpson_200+","+gini_simpson_500+","+gini_simpson_1000+","+
				exp_all_2+","+exp_all_5+","+exp_all_10+","+exp_all_20+","+
				exp_all_50+","+exp_all_100+","+exp_all_200+","+exp_all_500+","+exp_all_1000+",";
			
			
			writeFile(results_file, output, append=T);
		
		}
		
		sim.simulationFinished();
	
	}
}



fitness(NULL) {
	if (genome1.countOfMutationsOfType(m1) & genome2.countOfMutationsOfType(m1)){
		return 1.0 + s;
	}
	else if (genome1.countOfMutationsOfType(m1) | genome2.countOfMutationsOfType(m1)){
		return 1.0 + h*s;
	}
	else{
		return 1.0;
	}
}

